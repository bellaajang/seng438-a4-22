**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 – Mutation Testing and Web app testing**

| Group \#:      |     |
| -------------- | --- |
| Student Names: |     |
|    Suyoung            |     |
|    Joseph            |     |
|    Joan            |     |
|    Raghav            |     |

# Introduction

The goal of this lab was to enhance the quality and completeness of our test suite by applying mutation testing to the test cases for Range and DataUtilities from Assignment 3. Using PIT, we injected mutants into the source code and analyzed it for mutation coverage. Additionally, the assignment aimed to introduce GUI testing tools for testing one of the provided websites. For this, we used Selenium to record and replay GUI test scripts.

# Analysis of 10 Mutants of the Range class
1. Mutation on line 105: replaced double return with 0.0d  → KILLED

This mutation is in the getLowerBound function, and replaces the return value with 0.0. Several of our test cases kill this mutation, one of which is testGetLowerBoundForFiniteValue(), where the Range has a lower bound of -10 and asserts that the return value is equal to -10, so when the mutation changes the return value to 0, the test fails and the mutant is killed.

2. Mutation on line 114: Incremented (a++) double field upper → SURVIVED

This mutation is in the getUpperBound function, and after the value of this.upper is returned it increments the value. This mutation is not caught by any of our test cases because we have no test that checks that the upper bound of the Range remains unchanged after the function is executed.

3. Mutation on line 123: Replaced double subtraction with addition → KILLED

This mutation is in the getLength function, and replaces the subtraction with addition. Several of our test cases kill this mutation, one of which is getLengthWithBothBoundsPositive(), where the range 10,20, so expected length is 10, but with the mutation the returned length is 30, thus it is not asserted equal, the test fails and the mutant is killed.

4. Mutation on line 132: Substituted 2.0 with 1.0 → KILLED

This mutation is in the getCentralValue function, and replaces the first 2 in this.lower / 2.0 + this.upper / 2.0 with a 1. The testGetCentralValue() kills this mutation, as the range is 5.0,15.0, so the expected central value is 10.0, but when the mutation happens the return value is 12.5, thus it is not asserted equal, the test fails and the mutant is killed.

5. Mutation on line 132: Incremented (++a) double field lower → KILLED

This mutation is in the getCentralValue function, the value of this.lower is incremented and then used to return. The testGetCentralValue() kills this mutation, as the range is 5.0,15.0, so the expected central value is 10.0, but when the mutation happens the return value is 10.5, thus it is not asserted equal, the test fails and the mutant is killed.

6. Mutation on line 161: Decremented (a--) double local variable number 1 → SURVIVED

This mutation is in the intersects(double b0, double b1) function, and after the value of b0 is used to evaluate the return value it decrements b0. This mutation is not caught by any of our test cases because we have no test that checks that the local variable b0 that the function used remains unchanged after the function is executed.

7. Mutation on line 197: Negated double local variable number 3 → KILLED

This mutation is in the constrain function, and negates the variable result before it is returned. Several of our test cases kill this mutation, one of which is testConstrainWithinRange(), which has a Range 5,10 and tests a constrain value of 7. The expected return value is 7, but with the mutation -7 is returned, thus it is not asserted equal, the test fails and the mutant is killed.

8. Mutation on line 217: removed conditional - replaced equality check with true → KILLED

This mutation is in the combine function, and replaces the checking if range1 is null with true. This mutation is killed by testCombineWithOverlappingRanges(), because if the first if statement is true, it completely ignores range1 in making the new range, so instead of having the new expected range of -2,7, it is only range2 so -2,3, thus it is not asserted equal, the test fails and the mutant is killed.

9. Mutation on line 448: replaced boolean return with false for → KILLED

This mutation is in the isNaNRange function, and makes the return false. This mutation is killed by testIsNaNRange(), because it has the assertion assertTrue(new Range(Double.NaN, Double.NaN).isNaNRange(), and since the return is false the test fails and the mutant is killed.

10. Mutation on line 475: replaced return value with "" → KILLED

This mutation is in the toString function, and makes the return value “”. This mutation is killed by several tests, one of which is testToStringWithZero(), which has expected = "Range[0.0,0.0]", so when the return value is “”, it is not asserted equal, the test fails and the mutant is killed. 


# Report all the statistics and the mutation score for each test class
## Range Initial Mutation Score

![Screenshot 2025-03-26 213927](https://github.com/user-attachments/assets/8006ad67-6bb6-4d0a-ad3a-d3c6252e4b50)

## Range Final Mutation Score

![Screenshot 2025-03-28 001644](https://github.com/user-attachments/assets/ebfa250b-39a0-4ea7-9aa4-94e3ffd24643)

## DataUtilities Initial Mutation Score

![Screenshot 2025-03-27 205604](https://github.com/user-attachments/assets/d397657c-aee1-4b31-b25b-a48e5b35eaa5)

## DataUtilities Final Mutation Score


# Analysis drawn on the effectiveness of each of the test classes

The effectiveness of RangeTest and DataUtilities can be compared based on their coverage and mutation scores.

RangeTest started with 100% line coverage, 70% mutation coverage, and 70% test strength. Improvements brought mutation coverage to 80%, and test strength to 80%. The mutation score suggests it is relatively robust.

DataUtilities, on the other hand, began with 100% line coverage, 91% mutation coverage, and 91% test strength. After minor refinements, these scores increased to 100%, 91%, and 91%, respectively, indicating higher initial and overall effectiveness.

In summary, DataUtilities outperformed RangeTest with greater robustness and fewer required improvements.

# A discussion on the effect of equivalent mutants on mutation score accuracy
// A discussion on the effect of equivalent mutants on mutation score accuracy including a discussion on how equivalent mutants could be detected
// Try to come up with a way that you could automatically detect a few equivalent mutants in your experimentation, for classes Range and DataUtilities. 
// If you think you have found a way, discuss it in your report, along with its benefits, disadvantages, and assumptions. Try to detect a few equivalent 
// mutants manually in classes Range and DataUtilities (to do this, you will need to investigate the mutation logs generated by the tool). 
// Report the process you followed for this part plus your findings and results in your lab report.

# A discussion of what could have been done to improve the mutation score of the test suites
// A discussion of how you improved the mutation score of the test suites. Your design strategy.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing



# Explain your SELENUIM test case design process

# Explain the use of assertions and checkpoints

# How did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix

# How the team work/effort was divided and managed

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the lab itself
The instructions for this lab were often confusing. Additionally, when we encountered issues with Eclipse or the lab setup, it would have been helpful 
to include a note in the assignment markdownabout the need to import jar files from Assignment Two, and explaining how to import the sample test suites.
